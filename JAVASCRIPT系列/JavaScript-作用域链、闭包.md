# JavaScript作用域&&闭包

## 一、作用域空间、变量提升hoisting
JavaScript中只存在function级作用域,ES6支持let,const用于创建block作用域，**在循环+异步调用** 时经常使用。
* 变量提升
``` JavaScript
    a = 2;
    var a;
    console.log(a); //2
```
* 函数提升
```JavaScript
    console.log(f1); // 函数声明式 发生函数提升
    console.log(f2); //undefined
    function f1(){}; //函数声明式
    var f2 = function(){} //函数字面量
```
### 总结:
1. var a = 2;其中var a在**编译阶段**，a=2在**执行阶段**;
2. 不加var，直接写a = 2,发生在**运行阶段**引擎会沿着[[scope]],一直查找到全局作用域，如果没有找到，则在window的全局作用域下创建变量 a
3. 无论作用域中的声明（变量和函数）出现在什么地方，都将在代码本身执行前首先进行处理；
4. 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升；
5. 函数会首先被提升，然后才是变量，重复的var（变量）声明会被忽略掉；
6. 后面的函数声明可以覆盖前面的。
### PS：
1. RHS查询在所有嵌套的作用域中遍寻不到所需遍历会抛出**ReferenceError**。
2. RHS查询到一个变量，但你尝试对其不合理的操作（引用null或undefined类型中的属性），会抛出**TypeError**。

## 二、词法作用域、作用域链[[scope]]
作用域是关于**引擎**如何**寻找变量**以及会在何处找到变量的规则
- 词法作用域

    - 最重要特征是定义过程发生在代码书写截断

    - 作用域链基于代码的作用域嵌套而非调用栈

- 动态作用域是让作用域在代码运行过程中动态确定(C++、JAVA)

    - 不关心函数和作用域如何声明以及何处声明

    - 只关心从何处调用

    - 作用域链基于调用栈而不是代码的作用域嵌套

- JS 并不具有动态作用域只有词法作用域 -> this机制某种程度上很像动态作用域

![词法作用域](../imgs/JAVASCRIPT系列/词法作用域闭包/函数调用构造作用域链.png) <br/>
### 图解说明

## 三、闭包closure
### 一些关于闭包的定义：

	1. 闭包是指有权访问另一个函数作用域中变量的函数 --《JS高级程序设计第三版》 p178
	2. 函数对象可以通过作用域链相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为 ‘闭包’ 。 --《JS权威指南》 p183
	3. 内部函数可以访问定义它们的外部函数的参数和变量(除了this和arguments)。 --《JS语言精粹》 p36

### 定义总结

	1. 可以访问外部函数作用域中变量的函数
	2. 被内部函数访问的外部函数的变量可以保存在外部函数作用域内而不被回收---这是核心，后面我们遇到闭包都要想到，我们重点要关注被闭包引用的这个变量。


>只有当inner function引用了外层的变量时，该closure才会创建,实质上是在function expicity(显示的)添加了一个closure 引用属性 指向上级作用域空间

## 四、闭包与内存管理
### 函数执行过程
[javascript函数执行过程](https://www.cnblogs.com/liugang-vip/p/6337580.html)
d
![词法作用域](../imgs/JAVASCRIPT系列/词法作用域闭包/垃圾回收.png)]
![词法作用域](../imgs/JAVASCRIPT系列/词法作用域闭包/全局引用阻止内存回收.png)]

## 五、this动态绑定的特性 (call,apply,bind)

> JavaScript中的函数运行在它们被**定义时的作用域里**,而不是它们被执行的作用域里。
